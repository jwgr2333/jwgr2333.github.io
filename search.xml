<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STM32</title>
    <url>/2020/09/10/STM32/</url>
    <content><![CDATA[<img src="/2020/09/10/STM32/stm32.jpg" alt="image" style="zoom:25%;">

<h2 id="测控"><a href="#测控" class="headerlink" title="测控"></a>测控</h2><ul>
<li>被调剂到测控属实不行，啥都不会，发不了论文，学的前端也毫无作用。导师最后还是让我学习测控需要掌握的知识。</li>
<li>stm32</li>
<li>plc</li>
</ul>
<h2 id="STM32寄存器"><a href="#STM32寄存器" class="headerlink" title="STM32寄存器"></a>STM32寄存器</h2><p><video src="http://119.3.174.206:5001/public/videos/test.mp4" style="height:1600px; width: 1000px" autoplay controls></video></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/02/10/git/</url>
    <content><![CDATA[<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><ul>
<li><p>在第一次使用时需要配置相关信息，配置两步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;1329042571@qq.com&quot;&#x2F;&#x2F;全局配置邮箱</span><br><span class="line">git config --global user.name&quot;谢鑫&quot;&#x2F;&#x2F;全局配置姓名</span><br><span class="line">git config user.name&#x2F;&#x2F;查看当前配置用户名</span><br><span class="line">git config user.email&#x2F;&#x2F;查看当前配置邮箱</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个仓库</p>
<p>在需要提交git 的目录git bash here，然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitinit &#x2F;&#x2F;初始化</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们很容易遇到这样的错误</p>
</li>
</ul>
<p><img src="/2020/02/10/git/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200516110434481.png" alt="image-20200516110434481"></p>
<ul>
<li>这是文件无法跟踪，我们需要把这个文件加到git操作里面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add git练习.txt&#x2F;&#x2F;添加单个文件</span><br><span class="line">git add .  &#x2F;&#x2F;添加多个文件</span><br></pre></td></tr></table></figure>

<ul>
<li><p>提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;提交信息，必须写&quot;&#x2F;&#x2F;提交工作区的git代码到本地的git仓库</span><br></pre></td></tr></table></figure>
</li>
<li><p>版本回退</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^ &#x2F;&#x2F;回退一个版本</span><br><span class="line">git reset --hard HEAD^^ &#x2F;&#x2F;回退两个版本</span><br></pre></td></tr></table></figure>

<ul>
<li>当回退后又想前进怎么办？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard 10bcce3  &#x2F;&#x2F;回退指定的版本，后面的是具体版本的id</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看每个版本的id</p>
</li>
<li><pre><code class="git">git reflog
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 当我们想把本地的新仓库与远程的仓库连接起来</span><br><span class="line"></span><br><span class="line">+ 注意，如果是新的，那么最好是空仓库</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;git</span><br><span class="line">&#x2F;&#x2F;进入所在仓库的目录</span><br><span class="line">&#x2F;&#x2F;与远程仓库连接</span><br><span class="line">git remote add origin 仓库地址</span><br><span class="line">&#x2F;&#x2F;推送，</span><br><span class="line">&#x2F;&#x2F;可能要输入密码，就输入我的密码就行了，不是输入秘钥</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="加入已经有的仓库"><a href="#加入已经有的仓库" class="headerlink" title="加入已经有的仓库"></a>加入已经有的仓库</h3><ul>
<li><pre><code class="git">git clone
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 拉取</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;git</span><br><span class="line">git pull origin master &#x2F;&#x2F;从主分支拉取</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>git操作</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>js学习随手</title>
    <url>/2020/10/08/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h4><p>一直以来都比较迷惑，在js方法中的值传递与引用传递的区别，看个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    sum = sum + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">sum(a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a的值为&quot;</span>,a);<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>上述例子是很明显的值传递，传递到函数中的只有值（10），所以对num进行操作不会印象到外面的a，但是下面这个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">&quot;xx&quot;</span>;</span><br><span class="line">;&#125;</span><br><span class="line"><span class="keyword">var</span> object = &#123;&#125;;</span><br><span class="line">setName(object);</span><br><span class="line"><span class="built_in">console</span>.log(object);<span class="comment">//&#123;name: &quot;xx&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>??，如果是值传递为什么这个对象的值会改变呢？如果是引用传递那么下面这个Object的值为什么不是{}？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">&quot;xx&quot;</span>;</span><br><span class="line">    obj = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> object = &#123;&#125;;</span><br><span class="line">setName(object);</span><br><span class="line"><span class="built_in">console</span>.log(object);<span class="comment">//&#123;name: &quot;xx&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个问题困扰我许久，先说结论：<font color="red">ECMAScript中所有函数的参数都是按值传递的</font>，造成这一现象的原因是 <font color="red">在传递对象时，即使这个变量是按值传递的，obj也会按照引用来访问同一个对象</font>。在最后一个例子的函数中把{}赋值给obj，就是把一个新的对象赋值给了obj，这表示把另外一个对象（空对象）的引用给了obj。已经与传递的object没有任何关系了</p>
<h4 id="数组的length"><a href="#数组的length" class="headerlink" title="数组的length"></a>数组的length</h4><p>刚刚才发现，原来数组的长度arr.length。并不是一个只读属性，可以对它赋值的！！也就是说，如果想让数组尾部删除只需要</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.length = arr.length - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>以前我都是用slice函数这样做的，这让我比较好奇谁的性能更好呢，虽然感觉是length-1，但是测试看看吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">        arr.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(let i = 0; i &lt; 999999; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     arr.length = arr.length - 1;//72ms</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">999999</span>; i++)&#123;</span><br><span class="line">        arr = arr.slice(<span class="number">0</span>,arr.length<span class="number">-1</span>);<span class="comment">//直接超时了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其实不用测试，看slice原码</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice=<span class="function"><span class="keyword">function</span>(<span class="params">start,end</span>)</span>&#123;  <span class="comment">//ES5 中的数组方法slice的底层内部实现</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//新数组</span></span><br><span class="line">    <span class="keyword">var</span> start = start || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> end = end || <span class="built_in">this</span>.length; <span class="comment">//this指向调用的对象，用了call之后，改变this的指向，指向传进来的对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=start; i&lt;end; i++)&#123;</span><br><span class="line">        result.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;	<span class="comment">//返回的为一个新的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>vscode配置c++/java开发环境</title>
    <url>/2020/10/09/vscode%E9%85%8D%E7%BD%AEc-java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h4 id="安装C-流程"><a href="#安装C-流程" class="headerlink" title="安装C++流程"></a>安装C++流程</h4><h6 id="需要"><a href="#需要" class="headerlink" title="需要"></a>需要</h6><ul>
<li>VScode</li>
<li>MinGW</li>
<li>C/C++ （vscode插件）</li>
<li>Code Runner（vscode插件）</li>
<li>配置</li>
</ul>
<h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><ul>
<li>安装vscode，这个就不说了，<a href="https://code.visualstudio.com/Download">vscode地址</a>。没下的就按这个链接去下吧</li>
<li>MinGW，<a href="https://sourceforge.net/projects/mingw-w64/files/">MinGw</a>，进入网站后不要点击 “Download Lasted Version”，往下滑，找到最新版的 “x86_64-posix-seh”点击会自动下载。下载后是一个7z的压缩包，解压后移动到你想安装的位置即可。（上面是看的别人的博客，我也不知道为什么不下载最近的版本）。<font color="red">注意：解压的位置最好记住，以后的步骤会用到</font></li>
<li>配置环境变量</li>
</ul>
<img src="/2020/10/09/vscode%E9%85%8D%E7%BD%AEc-java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Snipaste_2020-10-09_15-24-49.png" alt="Snipaste_2020-10-09_15-24-49" style="zoom:80%;">

<p>​    操作的是用户变量的path，最下面这个就是新建的路径，我的是这个。对着来就行，操作完成之后再cmd中输入 g++ -v 如果不报错反而输出一长串就成功了</p>
<ul>
<li><p>打开vscode安装插件</p>
<img src="/2020/10/09/vscode%E9%85%8D%E7%BD%AEc-java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Snipaste_2020-10-09_15-29-34.png" alt="Snipaste_2020-10-09_15-29-34" style="zoom:75%;">

</li>
</ul>
<img src="/2020/10/09/vscode%E9%85%8D%E7%BD%AEc-java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Snipaste_2020-10-09_15-30-02.png" alt="Snipaste_2020-10-09_15-30-02" style="zoom:75%;">

<p>​    两个插件直接去搜索安装就可以了。</p>
<ul>
<li><p>新建一个文件夹，拖到vscode中，新建一个cpp文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你点击运行，或者调试，当然是还不能成功的，但是可以打开这两个json文件。修改launch.json,这里的miDebuggerPath路径是要自行修改的哦</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>, <span class="comment">// 配置名称，将会在启动配置的下拉菜单中显示</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>, <span class="comment">// 配置类型，这里只能为cppdbg</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>, <span class="comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>, <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [], <span class="comment">// 程序调试时传递给程序的命令行参数，一般设为空即可</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>, <span class="comment">// 设为true时程序将暂停在程序入口处，一般设置为false</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>, <span class="comment">// 调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录 workspaceRoot已被弃用，现改为workspaceFolder</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">true</span>, <span class="comment">// 调试时是否显示控制台窗口，一般设置为true显示控制台</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;D:\\Program Files\\C++\\mingw64\\bin\\gdb.exe&quot;</span>, <span class="comment">// miDebugger的路径，注意这里要与MinGw的路径对应</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;g++&quot;</span>, <span class="comment">// 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改tasks.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">        <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">        <span class="string">&quot;$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">    ], <span class="comment">// 编译命令参数</span></span><br><span class="line">    <span class="attr">&quot;problemMatcher&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;owner&quot;</span>: <span class="string">&quot;cpp&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fileLocation&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;relative&quot;</span>,</span><br><span class="line">            <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;pattern&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;regexp&quot;</span>: <span class="string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;file&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;severity&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">&quot;message&quot;</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;presentation&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;echo&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;reveal&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;focus&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;panel&quot;</span>: <span class="string">&quot;new&quot;</span>, <span class="comment">//这里shared表示共享，改成new之后每个进程创建新的端口</span></span><br><span class="line">        <span class="attr">&quot;showReuseMessage&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;clear&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不能打开，就自己在主目录下新建一个.vscode文件夹，然后把这两个文件放进去</p>
<img src="/2020/10/09/vscode%E9%85%8D%E7%BD%AEc-java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Snipaste_2020-10-09_15-35-50.png" alt="Snipaste_2020-10-09_15-35-50">
</li>
<li><img src="/2020/10/09/vscode%E9%85%8D%E7%BD%AEc-java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Snipaste_2020-10-09_15-38-27.png" alt="Snipaste_2020-10-09_15-38-27" sty="zoom:150%;"></li>
<li><p>搞定</p>
</li>
</ul>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><h6 id="需要-1"><a href="#需要-1" class="headerlink" title="需要"></a>需要</h6><ul>
<li>jdk</li>
<li>JAVA_HOME环境变量配置</li>
<li>CLASSPATH环境变量配置</li>
<li>vscode</li>
<li>Java Extentsion Pack插件</li>
<li>vscode配置</li>
</ul>
<h6 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h6><p>前四个步骤我就直接省略了，因为我已经有java环境了，网络上太多教这个的了。</p>
<ul>
<li>直接去vscode的extension搜索就可以了</li>
</ul>
<img src="/2020/10/09/vscode%E9%85%8D%E7%BD%AEc-java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Snipaste_2020-10-09_15-49-12.png" alt="Snipaste_2020-10-09_15-49-12" style="zoom:75%;">

<ul>
<li><p>vscode配置</p>
<p>使用ctrl+, 进入设置页面，然后搜索java home<img src="/2020/10/09/vscode%E9%85%8D%E7%BD%AEc-java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Users\Administrator\Desktop\newBlog4\source\_posts\vscode配置c-java开发环境\Snipaste_2020-10-09_15-46-22.png" alt="Snipaste_2020-10-09_15-46-22" style="zoom:100%;"></p>
<p>点击在setting.json中编辑，加入这一行即可</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;java.home&quot;: &quot;C:\\Program Files\\Java\\jdk-13.0.2&quot;,</span><br></pre></td></tr></table></figure>

<ul>
<li><p>完成，测试。新建一个文件夹，看看，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/10/09/vscode%E9%85%8D%E7%BD%AEc-java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Snipaste_2020-10-09_15-51-43.png" alt="Snipaste_2020-10-09_15-51-43" style="zoom:100%;">

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>webpack笔记</title>
    <url>/2020/09/12/webpack%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h2><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)*。当 *webpack</em> 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 *bundle</em>。 —— <em>webpack</em>官网</p>
<p>简而言之， webpack会</p>
]]></content>
  </entry>
  <entry>
    <title>js面试手写代码</title>
    <url>/2020/10/10/js%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<ol>
<li><p>数组扁平化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]]],<span class="number">6</span>];</span><br><span class="line"><span class="comment">//使用flat</span></span><br><span class="line"><span class="keyword">const</span> res = arr.flat(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">//利用正则</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="built_in">JSON</span>.stringify(arr).replace(<span class="regexp">/\[|\]/g</span>, <span class="string">&#x27;&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line"><span class="comment">//正则二</span></span><br><span class="line"><span class="keyword">const</span> res3 = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;[&#x27;</span>+<span class="built_in">JSON</span>.stringify(arr).replace(<span class="regexp">/\[|\]/g</span>, <span class="string">&#x27;&#x27;</span>)+<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> = <span class="title">arr</span> =&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr2 = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">            fn(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          arr2.push(arr[i]);  </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> res5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res5 = fn(arr);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">17</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, []];</span><br><span class="line"><span class="comment">//利用set</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line"><span class="comment">//两层for</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">                arr.splice(j, <span class="number">1</span>);</span><br><span class="line">            	len--;</span><br><span class="line">            	j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用indexOf</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res.indexOf(arr[i]) === <span class="number">-1</span>) res.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>类数组转化为数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用Array.from</span></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectAll(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"><span class="comment">//Array.prototype.slice.call()</span></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectAll(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"><span class="comment">//扩展运算符</span></span><br><span class="line"><span class="keyword">const</span> res3 = [...document.querySelectAll(<span class="string">&#x27;div&#x27;</span>)];</span><br><span class="line"><span class="comment">//concat</span></span><br><span class="line"><span class="keyword">const</span> res4 = <span class="built_in">Array</span>.prototype.concat.apply([], ocument.querySelectAll(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.prototype.filter()</p>
</li>
<li><p>Array.prototype.map()</p>
</li>
<li><p>Array.prototype.forEach()</p>
</li>
<li><p>Array.prototype.reduce()</p>
</li>
<li><p>Function.prototype.apply()</p>
</li>
<li><p>Function.prototype.call()</p>
</li>
<li><p>Function.prototype.bind()</p>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>主流浏览器及内核</title>
    <url>/2020/10/14/%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%8A%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<p>任何上过网的用户对浏览器是再熟悉不过了。只是用户看到仅仅只是浏览器本身，却很少能看到浏览器最核心的部分—浏览器内核。从第一款libwww（Library WorldWideWeb）浏览器发展至今已经经历了无数竞争与淘汰了。现在国内常见的浏览器有：IE、Firefox、QQ浏览器、Safari、Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360浏览器、UC浏览器、遨游浏览器、世界之窗浏览器等。但目前最为主流浏览器有五大款，分别是IE、Firefox、Google Chrome、Safari、Opera。<br>浏览器最重要的部分是浏览器的内核。浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。<br>简单介绍一下五大主流浏览器。（按时间顺序）<br>1、IE浏览器：<br>IE是微软公司旗下浏览器，是目国内用户量最多的浏览器。IE诞生于1994年，当时微软为了对抗市场份额占据将近百分之九十的网景Netscape Navigator，于是在Windows中开发了自己的浏览器Internet Explorer，自此也引发了第一次浏览器大战。结果可想而知，微软大获全胜，网景不得不将自己卖给AOL公司。但实际上事情并没有结束，网景后来开发了风靡一时的Firefox火狐，至今Firefox也成为世界五大浏览器之一。<br>1996年，微软从Spyglass手里拿到Spyglass Mosaic的源代码和授权，开始开发自己的浏览器IE。后来，微软以IE和Windows捆绑的模式不断向市场扩展份额，使IE成为市场的绝对主流。现在装了Windows系统的电脑基本无法卸载IE。<br>2、Opera浏览器：<br>Opera是挪威Opera Software ASA公司旗下的浏览器。1995年，opera公司发布第一版Opera浏览器，使用自己研发的Presto内核。当时opera公司的开发团队不断完善Presto内核，使Opera浏览器一度成为顶级浏览器。直到2016年奇虎360和昆仑万维收购了Oprea浏览器，从此也丢弃了强大的Presto内核，改用当时Google开源的webkit内核。后来Opera浏览器跟随Google将浏览器内核改为Blink内核。自此Presto内核也淡出了互联网市场。<br>3、Safari浏览器：<br>第二次浏览器大战是从苹果公司发布Safari浏览器开始的。2003年，苹果公司在苹果手机上开发Safari浏览器，利用自己得天独厚的手机市场份额使Safari浏览器迅速成为世界主流浏览器。Safari是最早使用webkit内核的浏览器也是现在苹果默认的浏览器。<br>4、Firefox浏览器：<br>Firefox浏览器使Mozilla公司旗下浏览器，也是刚才提到的网景公司后来的浏览器。网景被收购后，网景人员创办了Mozilla基金会，这是一个非盈利组织，他们在2004年推出自己的浏览器Firefox。Firefox采用Gecko作为内核。Gecko是一个开源的项目，代码完全公开，因此受到很多人的青睐。Firefox的问世加快了第二次浏览器大战的开始。第二次浏览器大战与第一次二元鼎力的局面不同，这一次的特点就是百家争鸣，也自此打破了IE浏览器从98年网景被收购后独步浏览器市场的局面。<br>5、Chrome浏览器：<br>Chrome浏览器是google旗下的浏览器。Chrome浏览器至发布以来一直讲究简洁、快速、安全，所以Chrome浏览器到现在一直受人追捧。最开始Chrome采用webkit作为浏览器内核，直到2013年，google宣布不再使用苹果的webkit内核，开始使用webkit的分支内核Blink。</p>
<p>以上是五大浏览器的简介，接下来是四大内核。在介绍五大浏览器的同时也已经顺便介绍了四大内核。四大内核分别是：Trident（也称IE内核）、webkit、Blink、Gecko。五大浏览器采用的都是单内核，而随着浏览器的发展现在也出现了双内核。像360浏览器、QQ浏览器都是采用双内核。<br>作为前端开发，熟悉四大内核是非常有必要的。四大内核的解析不同使网页渲染效果更具多样化。下面总结一下各常用浏览器所使用的内核。<br>1、IE浏览器内核：Trident内核，也是俗称的IE内核；<br>2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；<br>3、Firefox浏览器内核：Gecko内核，俗称Firefox内核；<br>4、Safari浏览器内核：Webkit内核；<br>5、Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；<br>6、360浏览器、猎豹浏览器内核：IE+Chrome双内核；<br>7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；<br>8、百度浏览器、世界之窗内核：IE内核；<br>9、2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；</p>
<p>写这篇文章主要是因为自己在前端开发过程常遇到浏览器兼容问题，以后有时间要对不同内核浏览器渲染效果的区别做一下总结。这是对不同浏览器和内核的总结，希望对大家有帮助。</p>
<p>转自<a href="https://blog.csdn.net/yuyanjing123456789/article/details/78689595">csdn,kookic</a></p>
]]></content>
  </entry>
  <entry>
    <title>吐槽200910</title>
    <url>/2020/09/10/%E5%90%90%E6%A7%BD200910/</url>
    <content><![CDATA[<h5 id="吐槽黄色衣服的小哥"><a href="#吐槽黄色衣服的小哥" class="headerlink" title="吐槽黄色衣服的小哥"></a>吐槽黄色衣服的小哥</h5><ul>
<li><p>刚进门就一个劲的推荐办卡</p>
</li>
<li><p>在解释自己已经有卡之后，沉浸了一段时间。</p>
</li>
<li><p>小哥发现头发侧面有点翘起来，让我去把这部分的头发做一下。（可能是因为头发长睡觉睡的）。我提出今天没时间，下次吧（委婉拒绝），小哥不依不饶，多次提出可以预约。我的耐心已经被消耗殆尽了。o(一︿一+)o！！最终忍无可忍直接拒绝。小哥甚至在拒绝后还是在絮絮叨叨。</p>
</li>
<li><p>下次还是选择其他的师傅吧，(⊙﹏⊙)。</p>
</li>
<li><p>想安安静静的剪个头发怎么这么难呢~</p>
</li>
</ul>
]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>理发店</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统学习笔记</title>
    <url>/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="概念、功能、目标"><a href="#概念、功能、目标" class="headerlink" title="概念、功能、目标"></a>概念、功能、目标</h4><p>操作系统是用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，包括命令接口（面向用户的接口）和程序接口（面向程序的接口）。其中，程序接口由一组系统调用组成</p>
<h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><h4 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h4><img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0864.png" alt="img_0864" style="zoom:25%;">

<h4 id="操作系统的运行机制与体系结构"><a href="#操作系统的运行机制与体系结构" class="headerlink" title="操作系统的运行机制与体系结构"></a>操作系统的运行机制与体系结构</h4><h6 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h6><ul>
<li><p>两种指令、两种处理器状态、两种程序</p>
<ul>
<li>特权指令、非特权指令</li>
<li>用户态、核心态（用寄存器PWD的标志位决定的，只有在核心态才能使用特权指令。进入核心态只能通过中断）</li>
<li>内核程序（运行在核心态，可以使用特权指令）、普通应用程序（普通程序只能使用非特权指令）</li>
</ul>
</li>
<li><p>内核</p>
<p>计算机上配置的底层软件，是操作系统最基本的功能，最核心的部分。实现操作系统内核功能的程序就是内核程序。</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0867.png" alt="img_0867" style="zoom:25%;">

</li>
</ul>
<h6 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h6><img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0868.png" alt="img_0868" style="zoom:25%;">

<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0869.png" alt="img_0869" style="zoom:25%;">

<h4 id="操作系统中断和异常"><a href="#操作系统中断和异常" class="headerlink" title="操作系统中断和异常"></a>操作系统中断和异常</h4><p>为了解决程序只能串行执行的缺点，效率太低</p>
<ol>
<li><p>当中断发生时，CPU立即进入核心态</p>
</li>
<li><p>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</p>
</li>
<li><p>对于不同的中断信号，会进行不同的处理</p>
<p>如果发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（如进   程切换、分配IO等）需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用     户态切换为核心态，使得操作系统获得计算机的控制权。有了中断才能实现多到程序并发执行。</p>
<h6 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h6></li>
</ol>
<ul>
<li><p>内中断与外中断</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0870.png" alt="img_0870" style="zoom:25%;">
</li>
<li><p>外中断的处理过程</p>
<ol>
<li>执行完每一个指令后，CPU都要检查当前是否有外部中断信号</li>
<li>如果检测到外部中断信号，都需要保护被中断进程的CPU环境。</li>
<li>根据中断信号类型转响应的中断处理程序</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li>
</ol>
</li>
</ul>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0872.png" alt="img_0872" style="zoom:25%;">

<h4 id="操作系统系统调用"><a href="#操作系统系统调用" class="headerlink" title="操作系统系统调用"></a>操作系统系统调用</h4><ul>
<li><p>为什么操作系统要提供系统调用功能？</p>
<p>如果开放进程任意调用，极易造成混乱。所以需要进程想要使用资源时，发送一个请求，然后让操作系统对其管理协调。 </p>
 <img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0873.png" alt="img_0873" style="zoom:25%;">
</li>
<li><p>系统调用与库函数的区别</p>
<p>库函数已经封装了一部分系统调用的功能</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>提供</th>
</tr>
</thead>
<tbody><tr>
<td>普通应用程序</td>
<td>可以直接进行系统调用，也可以使用库函数。有的库函数涉及系统调用。有的不涉及</td>
</tr>
<tr>
<td>编程语言</td>
<td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使得上层进行系统调用更加方便</td>
</tr>
<tr>
<td>操作系统</td>
<td>向上提供系统调用</td>
</tr>
<tr>
<td>裸机</td>
<td></td>
</tr>
</tbody></table>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0875.png" alt="img_0875" style="zoom:25%;">

</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h4 id="进程的定义、组成、组织方式、特征"><a href="#进程的定义、组成、组织方式、特征" class="headerlink" title="进程的定义、组成、组织方式、特征"></a>进程的定义、组成、组织方式、特征</h4><p>进程是什么？</p>
<p>程序就是一个指令序列，早期的计算机只支持单道程序</p>
<ul>
<li>计算机有多道程序运行时，系统会为每个运行的程序配置一个数据结构，称为进程控制块（PCB），用来描述进程的各种信息。程序段、数据段、PCB三部分组成了进程实体（进程映像）。创建进程就是创建进程实体的PCB，撤销进程就是撤销PCB。PCB是进程存在的唯一标志</li>
<li>进程有不同的定义<ol>
<li>进程是程序的一次执行过程</li>
<li>进程是一个程序及其数据在处理机上顺序执行发生的活动</li>
<li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
<li>进程是进程实体的运行过程，是系统资源分配的调度的一个独立单位</li>
</ol>
</li>
</ul>
<p>系统中各个进程之间是如何被组织起来的？</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0878.png" alt="img_0878" style="zoom:25%;">

<p>相比于程序，进程有哪些特征？</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0879.png" alt="img_0879" style="zoom:25%;">

<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0877.png" alt="img_0877" style="zoom:25%;">

<h4 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h4><ul>
<li>进程状态<ul>
<li>创建态 —— 进程正在被创建</li>
<li>运行态 —— 占有CPU，并在CPU上运行</li>
<li>就绪态 —— 已经具备运行条件，由于没有空闲CPU，而暂时不能运行</li>
<li>阻塞态 —— 因等待某一事件而暂时不能运行</li>
<li>终止态 —— 进程正在被终止</li>
</ul>
</li>
</ul>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0880.png" alt="img_0880" style="zoom:25%;">

<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，包括创建新进程、撤销已有进程、实现进程状态转换等功能</p>
<ul>
<li><p>如何实现进程控制？</p>
<p>原语（不能被打断的程序），通过开中断、关中断指令，保证在切换进程状态时不被打断。避免出现异常</p>
</li>
<li><p>进程控制相关的原语</p>
<ol>
<li>更新PCB中的信息（修改进程状态标志，运行环境保存到PCB，从PCB恢复运行环境 ）</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
<li><img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0881.png" alt="img_0881" style="zoom:25%;">  </li>
<li><img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0882.png" alt="img_0882" style="zoom:25%;"> </li>
<li><img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0883.png" alt="img_0883" style="zoom:25%;"> </li>
<li><img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0884.png" alt="img_0884" style="zoom:25%;">               

</li>
</ol>
</li>
</ul>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><p> 进程之间的信息交换，由于进程是分配系统资源的单位。因此各个进程拥有的内存地址空间相互独立。为了保证安全，一个进程是不能直接访问另一个进程的地址空间。但是信息交换有时是必须的</p>
<p>实现方式</p>
<ul>
<li><p>共享存储（基于数据结构的共享/基于存储区的共享）</p>
<p>两个进程对共享空间的访问必须是互斥的</p>
</li>
<li><p>管道通信</p>
<ol>
<li>管道只能采用半双工通信，某一时间只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道</li>
<li>各个进程互斥的使用管道</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被堵塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被堵塞。</li>
<li>如果没写满就不允许读。如果没读空，就不允许写</li>
<li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据 的情况</li>
</ol>
</li>
<li><p>消息传递</p>
<p>直接通信（消息直接挂到接收进程的消息缓冲队列上）或间接通信（消息要先发送到中间实体（信箱）中）</p>
<p>数据交换以格式化的消息为单位，进程通过操作系统提供的发送/接收消息两个原语进行数据交换</p>
<ul>
<li><p>消息头</p>
<p>发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息</p>
</li>
<li><p>消息体</p>
</li>
</ul>
</li>
</ul>
<h4 id="线程与多线程模型"><a href="#线程与多线程模型" class="headerlink" title="线程与多线程模型"></a>线程与多线程模型</h4><ul>
<li><p>什么是线程？为什么要引入线程？</p>
<p>有的进程可能需要“同时”做很多事情，但是传统的进程只能串行的执行一系列程序，为此引入了线程，增加并发度。因此，<font color="red">线程是一个基本的CPU执行单元，也是程序执行流的最小单位</font>，引入线程后，不仅进程之间可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务。引入线程后<font color="red">进程只作为除CPU外的系统资源分配的单元</font></p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0887.png" alt="img_0887" style="zoom:80%;">

<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0888.png" alt="img_0888" style="zoom:80%;">
</li>
<li><p>线程的实现方式（两种）</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0890.png" alt="img_0890" style="zoom:80%;">

<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0892.png" alt="img_0892" style="zoom:80%;">
</li>
<li><p>多线程模型</p>
<p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0893.png" alt="img_0893" style="zoom:80%;">

<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0894.png" alt="img_0894" style="zoom:80%;">

<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0895.png" alt="img_0895" style="zoom:80%;">

</li>
</ul>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0896.png" alt="img_0896" style="zoom:80%;">

<h4 id="处理机调度的概念、层次"><a href="#处理机调度的概念、层次" class="headerlink" title="处理机调度的概念、层次"></a>处理机调度的概念、层次</h4><ul>
<li><p>调度是什么？</p>
<p>由于资源有限，没办法同时处理所有事情，因此确定某种规则决定处理下面任务的顺序</p>
</li>
<li><p>调度的三个层次——高级调度（作业调度）</p>
<p>​    按照一定的原则从外存上处于后备队列的作业中挑选一个（或者多个）的作业，给他们分配内存等必要资源，并建立相应的进程（PCB），使得他们获得竞争处理机的权利。</p>
<p>高级调度是辅存与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但是调出的时机必然是作业运行结束才调出</p>
</li>
<li><p>中级调度（内存调度）</p>
<p>引入虚拟存储技术，我们将暂时不能运行的进程调至外存等待，等他重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。</p>
<p>暂时调到外存等待的进程状态为<u>挂起状态</u>。值得注意的是，PCB并不会一起调到外存，而是会常驻内存，PCB会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p>
</li>
<li><p>低级调度（进程调度）</p>
<p>主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。频率很高，一般几十毫秒一次</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0897.png" alt="img_0897" style="zoom:80%;">

</li>
</ul>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0898.png" alt="img_0898" style="zoom:150%;">

<h4 id="进程调度的时机、切换与过程、方式"><a href="#进程调度的时机、切换与过程、方式" class="headerlink" title="进程调度的时机、切换与过程、方式"></a>进程调度的时机、切换与过程、方式</h4><p>什么时候进行进程调度呢？</p>
<ul>
<li>当前运行的进程主动放弃处理机<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求堵塞（如等待I/O）</li>
</ul>
</li>
<li>当前运行的进程被动放弃处理机<ul>
<li>分给进程的时间片处理完</li>
<li>有更紧急的事情需要处理</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
<p>进程调度的方式</p>
<ul>
<li>非剥夺方式，只允许进程主动放弃处理机</li>
<li>剥夺方式，当一个进程正在处理机上执行时，如果有一个更紧迫的进程需要使用处理机，则立即暂停正在运行的进程，把处理机分配给更紧迫的进程。</li>
</ul>
<p>进程切换</p>
<p>一个进程让出处理机，由另一个占用处理机的过程，包括对原来运行进程各个数据的保存（把寄存器等数据保存到PCB中），新的进程各种数据的恢复（把PCB的数据恢复到寄存器、程序计数器、程序状态字中）</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/.img_0899.png" alt="img_0899" style="zoom:150%;">

<h4 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h4><p>CPU利用率</p>
<p>系统吞吐量</p>
<p>周转时间</p>
<p>​    完成时间-到达时间</p>
<p>​    带权周转时间 = 周转时间/运行时间</p>
<p>等待时间</p>
<p>​    完成时间-运行时间-到达时间</p>
<p>响应时间</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0899.png" alt="img_0899" style="zoom:150%;">

<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0912.png" alt="img_0912" style="zoom:150%;">

<h4 id="FCFS、SJF、HRRN调度算法"><a href="#FCFS、SJF、HRRN调度算法" class="headerlink" title="FCFS、SJF、HRRN调度算法"></a>FCFS、SJF、HRRN调度算法</h4><p>算法思想、算法规则、用于作业调度/进程调度、抢占式、非抢占式、优缺点、导致饥饿？</p>
<ol>
<li><p>FCFS 先来先服务</p>
<p>主要从公平考虑、按照先后顺序进行服务、用于作业/进程调度时，都是看谁先到达、非抢占式。</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0914.png" alt="img_0914" style="zoom:150%;">
</li>
<li><p>SJF 短作业优先</p>
<p>抢占式的版本新来的任务会与目前任务的剩余时间比较。</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0915.png" alt="img_0915" style="zoom:150%;">
</li>
<li><p>HRRN 高响应比优先</p>
<p>响应比 = 等待时间+要求服务时间/要求服务时间，要求响应比大的优先</p>
<img src="/2020/09/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/img_0917.png" alt="img_0917" style="zoom:150%;">

</li>
</ol>
<h4 id="调度算法；时间片轮转、优先级、多级反馈队列"><a href="#调度算法；时间片轮转、优先级、多级反馈队列" class="headerlink" title="调度算法；时间片轮转、优先级、多级反馈队列"></a>调度算法；时间片轮转、优先级、多级反馈队列</h4><h4 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h4><h4 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h4><h4 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h4><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><h4 id="用信号量实现进程互斥、同步、前驱关系"><a href="#用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量实现进程互斥、同步、前驱关系"></a>用信号量实现进程互斥、同步、前驱关系</h4><h4 id="生产者、消费者问题"><a href="#生产者、消费者问题" class="headerlink" title="生产者、消费者问题"></a>生产者、消费者问题</h4><h4 id="多生产者，消费者问题"><a href="#多生产者，消费者问题" class="headerlink" title="多生产者，消费者问题"></a>多生产者，消费者问题</h4><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><h4 id="死锁的处理策略-预防和解除"><a href="#死锁的处理策略-预防和解除" class="headerlink" title="死锁的处理策略-预防和解除"></a>死锁的处理策略-预防和解除</h4><h4 id="死锁的处理策略-如何避免死锁"><a href="#死锁的处理策略-如何避免死锁" class="headerlink" title="死锁的处理策略-如何避免死锁"></a>死锁的处理策略-如何避免死锁</h4><h4 id="死锁的处理策略-检测和解除"><a href="#死锁的处理策略-检测和解除" class="headerlink" title="死锁的处理策略-检测和解除"></a>死锁的处理策略-检测和解除</h4><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h4 id="内存基础知识"><a href="#内存基础知识" class="headerlink" title="内存基础知识"></a>内存基础知识</h4><h4 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h4><h4 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h4><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><h4 id="基本分页存储管理的基本概念"><a href="#基本分页存储管理的基本概念" class="headerlink" title="基本分页存储管理的基本概念"></a>基本分页存储管理的基本概念</h4><h4 id="基本地址交换"><a href="#基本地址交换" class="headerlink" title="基本地址交换"></a>基本地址交换</h4><h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h4><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><h4 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h4><h4 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h4><h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><h4 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h4><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h4 id="文件管理初始"><a href="#文件管理初始" class="headerlink" title="文件管理初始"></a>文件管理初始</h4><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><h4 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h4><h4 id="文件存储空间"><a href="#文件存储空间" class="headerlink" title="文件存储空间"></a>文件存储空间</h4><h4 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h4><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><h4 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h4><h4 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h4><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><h4 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h4><h4 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h4><h2 id="I-O"><a href="#I-O" class="headerlink" title="I-O"></a>I-O</h2><h4 id="I-O-设备的概念与分类"><a href="#I-O-设备的概念与分类" class="headerlink" title="I-O 设备的概念与分类"></a>I-O 设备的概念与分类</h4><h4 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I-O控制器"></a>I-O控制器</h4><h4 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I-O控制方式"></a>I-O控制方式</h4><h4 id="I-O软件层次结构"><a href="#I-O软件层次结构" class="headerlink" title="I-O软件层次结构"></a>I-O软件层次结构</h4><h4 id="I-O核心子系统"><a href="#I-O核心子系统" class="headerlink" title="I-O核心子系统"></a>I-O核心子系统</h4><h4 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h4><h4 id="设备的分配与回收"><a href="#设备的分配与回收" class="headerlink" title="设备的分配与回收"></a>设备的分配与回收</h4><h4 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h4>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>如何生成一个自己的hexo博客</title>
    <url>/2020/09/08/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>全局安装hexo-cli，注意，是基于node的。需要安装node.js。安装完成检验一下，在文件夹里面按住shift点击鼠标右键打开powershell窗口输入npm -v , node -v查看版本。如果报错，可能是你还没有开放权限</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、以管理员权限运行 Windows PowerShell</span><br><span class="line"><span class="number">2</span>、输入如下命令：</span><br><span class="line">set-ExecutionPolicy RemoteSigned</span><br><span class="line"><span class="number">3</span>、根据提示输入A</span><br></pre></td></tr></table></figure>

<p>如果没问题，可以npm i -g hexo-cli全局安装了。当然也可以使用淘宝镜像。安装完成后就可以进入下一步了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//鉴于大家可能没有使用过npm，建议把地址修改一下</span></span><br><span class="line">npm config set registry https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"><span class="comment">//输入以下代码查看当前默认站点。如果是taobao就成功了</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>创建一个blog文件夹并进入，当然，起名可以无所谓。在这里打开powershell窗口，使用hexo init 初始化。等待完成后，hexo s 启动服务。这样你就拥有了一个最初的模板了。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>显然，我们不可能只在本地使用，那就直接搞md算了，何必用hexo。为了把我们的博客部署到github上，我们需要在主目录下 npm i -S hexo-deployer-git 安装这个插件帮助我们。接下来，修改一下主目录的_config.yml文件的deploy属性如图</p>
<p><img src="https://jwgr2333.github.io/imgs/image-20200908201329857.png" alt="image-20200908201329857"></p>
<p>注意空格，同时在github需要创建一个仓库，取名一定是username.github.io  参照我的。随后使用命令，</p>
<p>hexo clean,hexo g, hexo d 就完成了往github的上传。这时，在浏览器输入 <a href="https://username.github.io/">https://username.github.io</a> 就可以看到啦（需要等待一小会儿）。</p>
<p><font color="red">此外，有一些配置也是可以改的，比如title, languages, 等 如果是部署到个人的云服务器上的话可能需要修改URL，我是在github上所以可以暂时不用改</font></p>
<h2 id="主题theme"><a href="#主题theme" class="headerlink" title="主题theme"></a>主题theme</h2><p>当我们在完成以上的操作后，我们就拥有的自己的一个博客。但是这个博客的功能还是比较简陋的，为了方便，我们可以借用他人开源的一些基于hexo的主题帮助我们更好的装饰我们的博客。这里我使用的是butterfly。注意，如果没有安装git的话是需要安装git并配置一下用户名和email的。此外，也需要一个GitHub帐号。</p>
<p>github地址: <a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a>  没事去点个star吧，确实好用~</p>
<ul>
<li><p>安装</p>
<p>安装也比较简单，在主文件夹克隆一下butterfly到themes目录下的butterfly文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b master https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;butterfly</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置</p>
<p>修改主目录下的_config.yml文件的theme属性为butterfly，如图_。理论上其他主题可能也可以这样改。当然我只是猜测~</p>
<p><img src="https://jwgr2333.github.io/imgs/image-20200908202410942.png" alt="image-20200908202410942"></p>
<p>如果没有pug &amp; stylus renderer,作者也说了，需要这个.那我们就可以安装一下，因为已经安装了node，所以只需要在命令行操作即可    </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure>

<ul>
<li><p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean, hexo g, hexo s &#x2F;&#x2F;看看效果</span><br></pre></td></tr></table></figure>

<p>理论上已经可以看到自己的博客啦，如果对这个主题不太满意，可以去看看别的主题。总有一款适合你~</p>
</li>
</ul>
<h2 id="功能完善"><a href="#功能完善" class="headerlink" title="功能完善"></a>功能完善</h2><p>做完前面的工作之后，发现可能还是不能满足我的要求，着实有点素。于是我开始了个性化定制~ 这个时候就遇到了一些困难。可能版本不同，网络上先行者的建议与我的还是有点出入。于是，我开始自己查看目录。在butterfly的source目录下出现了_config.yml配置文件。这个文件可能是与主目录下的_config.yml文件合并或覆盖的。因此，修改此文件应该可以解决我们的问题。</p>
<ul>
<li><p>menu</p>
<p>刚打开时menu是被注释掉的，显然，menu还是需要的，我们取消注释并稍微修改一下，注意！！我们修改的时候可以 hexo s 把项目运行起来，这样我们能及时补救错误</p>
<p><img src="https://jwgr2333.github.io/imgs/image-20200908204113865.png" alt="image-20200908204113865"></p>
</li>
<li><p>Image设置</p>
<p>图片在代码中都有详细的提示，这里我就不过多说了，是选择删掉原图替换还是找网图都是可以的</p>
</li>
</ul>
<p><img src="https://jwgr2333.github.io/imgs/image-20200908205136691.png" alt="image-20200908205136691"></p>
<ul>
<li><p>categories、tags功能的实现</p>
<p>在我们把menu搞定之后，虽然出现了一排menu，可是我们却点击不了。这是因为我们还没有这个页面呀，我们可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &#39;pagename&#39;</span><br></pre></td></tr></table></figure>

<p>创建页面，这个创建的是页面，名字与上面menu是对应的，你可以继续如 hexo new page tags。以此类推我们可以创建categories， messageboard等把你需要的页面都创建出来。创建出来后我们是可以不用管创建出的文件的。我们需要做的是在新建的hexo new ‘new article’中把tags、categories写上即可。</p>
<p><img src="https://jwgr2333.github.io/imgs/image-20200908210251643.png" alt="image-20200908210251643"></p>
</li>
</ul>
<ul>
<li><p>comment功能的实现，要实现评论功能，我们这里借助的是Valine，需要</p>
<ul>
<li><p>注册<a href="https://leancloud.cn/dashboard/login.html#/signin">LeanCloud</a></p>
</li>
<li><p>创建应用：选择开发板即可。创建完成后进入应用keys，复制AppId、AppKey。粘贴到</p>
<p><img src="https://jwgr2333.github.io/imgs/image-20200908211005945.png" alt="image-20200908211005945"></p>
<p>注意，在这一行需要把comments下的Valine加上，当然你也可以用其他的。这里就相应的修改</p>
<p><img src="https://jwgr2333.github.io/imgs/image-20200908211034230.png" alt="image-20200908211034230"></p>
</li>
</ul>
</li>
</ul>
<p>然后还有字数统计、特效等功能，只要你想开都是可以的。因为作者是香港人，所以有中文提示，按照提示来就完事了。</p>
<p><font color="red">在设置评论时，同时发现了一个问题，即不只是在messageboard下有评论框，在categories、tags下面都有。只需要在创建的index页面下加入这个即可</font></p>
<pre><code>comments: false</code></pre>
<p><img src="https://jwgr2333.github.io/imgs/image-20200909200350809.png" alt="image"></p>
<h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><p>​    推荐使用hexo-asset-image插件。 在主目录使用 npm install <a href="https://github.com/CodeFalling/hexo-asset-image">https://github.com/CodeFalling/hexo-asset-image</a> – save。安装完成后使用hexo new ‘page’的时候回生成一个同名页面。把图片先放进去再引入即可，</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>暂时就写到这里吧，还有东西是我没有完善的。比如友链、music、videos、线上管理等。日后有时间可以继续完善吧~ 今天先做到这里。不得不说，hexo是一个非常优秀的博客框架。采用Markdown简直不要太方便。对我来说友好度爆棚。。而且用户庞大，意味着可以踩着前人的肩膀上前进。非常感谢先驱者的付出.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>作者：<a href="https://github.com/jerryc127">jerryc127</a>，github链接：<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a><br>作者：<a href="https://me.csdn.net/weixin_43350051">XJHui’s Blog</a>，文章链接：<a href="https://blog.csdn.net/weixin_43350051/article/details/104923503">https://blog.csdn.net/weixin_43350051/article/details/104923503</a></p>
]]></content>
      <categories>
        <category>blog build</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数控系统</title>
    <url>/2020/09/16/%E6%95%B0%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="数控系统指令"><a href="#数控系统指令" class="headerlink" title="数控系统指令"></a>数控系统指令</h2><h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><ul>
<li>G 准备功能指令</li>
<li>M 辅助功能指令</li>
<li>F 进给速度指令 如F100</li>
<li>S 主轴速度功能指令 （一定在零件加工前启动主轴运转）</li>
<li>T 指令 Tnn  刀具功能指令</li>
</ul>
<h4 id="常用准备功能指令"><a href="#常用准备功能指令" class="headerlink" title="常用准备功能指令"></a>常用准备功能指令</h4><ul>
<li><p>与坐标系有关的指令</p>
<ol>
<li>绝对坐标与增量坐标指示 —— G90、G91</li>
<li>坐标系设定指示 —— G92</li>
<li>坐标平面选择指令 —— G17、G18、G19 分别对应XY、ZX、YZ坐标平面的功能。</li>
</ol>
</li>
<li><p>运动控制指令</p>
<ol>
<li><p>快速点定位指令 —— G00，使刀具从当前位置以系统设定的最快速度快速移动到目的点。（快速定位）</p>
<p><font color="red">注意，最好了解操作机床的运动轨迹。三种方式中了解其中一种</font></p>
</li>
<li><p>直线插补指令——G01，该功能是直线运动控制指令，它命令刀具从当前位置以两坐标或三坐标联动方式按指定的F进给速度作任意斜率的直线运动到达指定的位置。该指令一般用作轮廓切削、</p>
<ul>
<li>格式：G01 X- Y- Z- F-；其中，XYZ为直线终点的绝对或增量坐标。F为沿插补方向的进给速度</li>
</ul>
<p><font color="red">G01指令既可以双坐标联动插补运动，又可以三坐标两栋插补运动，取决于数控系统的功能，当指令后面只有两个坐标值时，刀具将作平面直线插补，若有三个坐标值时，将做空间直线插补</font></p>
</li>
</ol>
</li>
<li><p>圆弧插补指令——G02、G03</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>歌词解析</title>
    <url>/2020/09/28/%E6%AD%8C%E8%AF%8D%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>不务正业中。。基础没打好天天搞这些花里胡哨的。确实应该再打好基础。</p>
<p>可是光看书和视频实在太枯燥了。每天给自己点时间写写页面也还挺开心的。</p>
<p>那么我们的uniapp网易云已经进行到了播放界面。光实现唱片效果显然不太够呀。歌词显示不能没有！！本着我可以不看但是你不能没有的原则。奥利给干了，兄弟们</p>
<p>那么我们看一下后台api发过来的歌词</p>
<p><image src="./Snipaste_2020-09-28_11-29-04.png"></image></p>
<p>一坨字符串，意料之中。</p>
<p>我的目的是把它解析成这样的样子</p>
<p><image src="./Snipaste_2020-09-28_11-32-30.png"></image></p>
<p>直接上代码吧</p>
<p>​    我是采用的原生ajax获取歌词文件，重点是处理歌词的思路。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lrc = []</span><br><span class="line">       <span class="keyword">var</span> lyric = <span class="literal">null</span></span><br><span class="line">       <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">       <span class="comment">//这个是把后台部署到我自己的服务器上了。</span></span><br><span class="line">       xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://119.3.174.206:3000/lyric?id=528326686&#x27;</span>)</span><br><span class="line">       xhr.send()</span><br><span class="line">       xhr.onload = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">           <span class="comment">//获取到了歌词对象</span></span><br><span class="line">           <span class="keyword">const</span> res = <span class="built_in">JSON</span>.parse(xhr.response)</span><br><span class="line">           <span class="comment">//console.log(res.lrc.lyric)</span></span><br><span class="line">           <span class="comment">//用正则对歌词分隔</span></span><br><span class="line">           lyric = res.lrc.lyric.split(<span class="regexp">/\n/</span>)</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lyric.length; i++)&#123;</span><br><span class="line">               <span class="keyword">let</span> lrcObj = &#123;</span><br><span class="line">                   time: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                   lrc: <span class="string">&#x27;&#x27;</span></span><br><span class="line">               &#125;</span><br><span class="line">               lrcObj.time = lyric[i].slice(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">               lrcObj.lrc = lyric[i].slice(<span class="number">11</span>,lyric.length<span class="number">-1</span>)</span><br><span class="line">               lrc.push(lrcObj)	</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">console</span>.log(lrc)</span><br><span class="line">       &#125; </span><br></pre></td></tr></table></figure>

<p><font color="skyblue"> 注意：这个是针对我当前的歌词类型解析的，实际应该是不能通用的。但是能够满足我的当前需求 。后续我会在复习基础时用正则做一次</font></p>
<p>渲染歌词到页面上</p>
]]></content>
  </entry>
  <entry>
    <title>计算机组成原理笔记</title>
    <url>/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>计算机底层硬件是如何协调工作的</li>
<li>硬件之间的数据传输</li>
<li>数字、文字、图像如何用二进制表示</li>
<li>如何存储这些二进制数的</li>
<li>如何对这些二进制数进行计算</li>
<li>如何从内存中读取想要的数据</li>
<li>平时写的程序如何被CPU识别和执行</li>
</ol>
<h5 id="硬件的发展"><a href="#硬件的发展" class="headerlink" title="硬件的发展"></a>硬件的发展</h5><ul>
<li><p>电子管 （1946-1957）-&gt; 晶体管（1958-1964体积小） -&gt; 中小规模集成电路 （1964-1971稳定）-&gt; 大规模、超大规模继承电路（1972- 开始诞生操作系统），逻辑元件越来越小，单位面积的逻辑元件越来越多，功耗越来越低</p>
</li>
<li><p>仙童半导体公司</p>
</li>
<li><p>摩尔定律：集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍</p>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0821.png" alt="计算机发展历程" style="zoom: 25%;">

</li>
</ul>
<h5 id="计算机的硬件基本组成"><a href="#计算机的硬件基本组成" class="headerlink" title="计算机的硬件基本组成"></a>计算机的硬件基本组成</h5><ul>
<li>早期冯洛伊曼机<ul>
<li>计算机由五大部件组成 输入设备、存储器、运算器、控制器、输出设备。</li>
<li>指令和数据以同等地位存于存储器，可以按地址寻访</li>
<li>指令和数据用二进制表示</li>
<li>指令由操作码和地址码组成。</li>
<li>以运算器为中心</li>
</ul>
</li>
</ul>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0822.png" alt="知识回顾" style="zoom:25%;">

<ul>
<li><p>认识各个硬件部件</p>
<ul>
<li><p>主存储器</p>
<ul>
<li>存储体（存储数据的地方）<ul>
<li>存储单元</li>
<li>存储字</li>
<li>存储字长</li>
<li>存储元</li>
</ul>
</li>
<li>MAR（存储地址寄存器）<ul>
<li>位数等于存储字长</li>
</ul>
</li>
<li>MDR（存储数据寄存器）<ul>
<li>每个存储单元可以存放16bit，一个字 = 16bit</li>
</ul>
</li>
</ul>
<p>1B为一个字节，1个字节为8bit</p>
</li>
<li><p>运算器的基本组成</p>
<p>用于实现算术运算（如：加减乘除、逻辑运算）</p>
<ul>
<li>ACC 累加器</li>
<li>MQ 乘商寄存器，用于在乘除运算时，存放操作数或者运算结果</li>
<li>X 通用操作数寄存器，存放操作数</li>
<li>ALU 算数逻辑单元(核心部件)，通过内部复杂电路实现算数运算、逻辑运算</li>
</ul>
</li>
<li><p>控制器的基本组成</p>
<ul>
<li><p>CU：控制单元、分析指令、给出控制信号</p>
</li>
<li><p>IR：指令寄存器，存放当前执  行的指令</p>
</li>
<li><p>PC：程序计数器，存放下一条指令地址，有自动加一的功能 </p>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0823.png" alt="img_0823" style="zoom:25%;">
</li>
</ul>
</li>
<li><p>编译程序与解释程序</p>
<ul>
<li>编译：将源程序全部语句一次全部翻译成机器语言程序，然后再执行机器语言程序（只需翻译一次）</li>
<li>解释：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行，紧接着再翻译下一句。</li>
</ul>
</li>
<li><p>在收到指令后，硬件如何工作？</p>
</li>
<li><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0824.png" alt="img_0824" style="zoom:25%;">

</li>
</ul>
</li>
</ul>
<h5 id="计算进数制"><a href="#计算进数制" class="headerlink" title="计算进数制"></a>计算进数制</h5><ul>
<li><p>数据如何在计算机中表示？</p>
</li>
<li><p>运算器如何实现数据的运算？</p>
</li>
<li><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0825.png" alt="img_0825" style="zoom:25%;">

<h5 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h5></li>
</ul>
<p>用四个二进制表示十进制。其中有四个是冗余的</p>
<ul>
<li>8421码，如果两个数相加落在了非法区间（1010-10010），那么需要加6进行修正 </li>
<li>余三码，8421码+（0011）<sub>2</sub></li>
<li>2421码</li>
<li><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0826.png" alt="img_0825" style="zoom:25%;">

</li>
</ul>
<h5 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h5><ul>
<li><p>ASCII码</p>
<ul>
<li>数字、字母、符号。共128个字符，刚好是2<sup>7</sup>。</li>
<li><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0827.png" alt="img_0825" style="zoom:25%;">
</li>
</ul>
</li>
<li><p>汉字的表示与编码</p>
<ul>
<li>GB2312-80</li>
</ul>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0828.png" alt="img_0825" style="zoom:25%;">

<h5 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h5></li>
</ul>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0829.png" alt="img_0825" style="zoom:25%;">

<h5 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h5><ul>
<li>把信息位进行分组，分别进行偶校验，多个校验位标注出错位置</li>
<li>2<sup>k</sup>  &gt; n+k+1(信息位加校验位加正确的情况)  </li>
<li><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0830.png" alt="img_0830" style="zoom:25%;">

</li>
</ul>
<h5 id="循环冗余校检码"><a href="#循环冗余校检码" class="headerlink" title="循环冗余校检码"></a>循环冗余校检码</h5><p>​    约定一个除数。信息位加校验位作为被除数。看余数是否为0</p>
<ul>
<li>模二除，模二减                                                                         </li>
</ul>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0831.png" alt="img_0831" style="zoom:25%;">

<h5 id="定点数、浮点数"><a href="#定点数、浮点数" class="headerlink" title="定点数、浮点数"></a>定点数、浮点数</h5><ul>
<li><p>整个机器字长的全部二进制均为数值位，没有符号位，相当于数的绝对值</p>
</li>
<li><p>无符号数</p>
</li>
<li><p>有符号数的定点表示（采用原码、反码、补码）</p>
<ul>
<li>原码<ul>
<li>采用-定点整数与定点小数表示，符号位+数值部分。</li>
</ul>
</li>
<li>反码（并没有太大的用处）<ul>
<li>如果符号位为0，反码与原码完全相同</li>
<li>如果符号位为1，则数值位完全取反</li>
</ul>
</li>
</ul>
</li>
<li><p>补码</p>
<ul>
<li>正数的补码为原码</li>
<li>负数的补码 = 反码末尾+1<ul>
<li>移码</li>
</ul>
</li>
<li>在补码的基础上将符号位取反，移码只用于整数</li>
<li><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0832.png" alt="img_0832" style="zoom:25%;">
+  减法操作可以通过补码转换成加法操作
+  <img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0834.png" alt="img_0834" style="zoom:25%;"></li>
</ul>
</li>
<li><p>强制类型转换</p>
<ul>
<li>有符号数转无符号数，改变解释方式，不改变数据内容</li>
<li>长整数变短整数。高位截短，保留低位</li>
<li>短数据转长数据，符号扩展</li>
</ul>
</li>
<li><p>数据的存储与排列</p>
<ul>
<li>存储字节的方式<ul>
<li>大/小端方式（存储方式由低字节到高字节，小端是反过来存储的 ）</li>
<li>边界对齐</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><p>为了解决当使用int字节不够时采用的存储数据的方式·分为阶码和尾数。</p>
<ul>
<li>阶码： 常用补码或移码表示的定点整数  E</li>
<li>尾数：常用原码或补码表示的定点小数   M                                 </li>
</ul>
<p>浮点数的真值 N = r <sup>E</sup> x  M  (r为阶码的底，一般为2)</p>
<p>为了让浮点数能存储更多的数据。左规与右规</p>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0835.png" alt="img_0835" style="zoom: 25%">

<h5 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h5><ul>
<li><p>存储器与CPU的协同工作</p>
<ul>
<li>存储器的简单模型及寻址的概念</li>
<li>主存与CPU的连接</li>
<li>双口RAM和多模块存储器</li>
<li>高速缓冲存储器</li>
<li>虚拟存储器</li>
</ul>
</li>
<li><p>半导体存储器</p>
<ul>
<li><p>存储芯片的基本结构</p>
<ul>
<li><p>存储矩阵：由大量相同的位存储单元阵列构成</p>
</li>
<li><p>译码驱动：将来自地址总线的地址信号翻译成对应存储单元的选通信号，该信号在读写电路的配合下完成对被选中单元的读/写操作。</p>
</li>
<li><p>读写电路：包括读出放大器和写入电路，用来完成读/写操作</p>
</li>
<li><p>读/写控制线：确定哪个存储芯片被选中，可用于容量扩充</p>
</li>
<li><p>片选线：确定哪个存储芯片被选中。可用于容量扩充</p>
</li>
<li><p>地址线：单向输入，其位数与存储字的个数有关</p>
</li>
<li><p>数据线：双向输入，其位数与读出或写入的数据位数有关</p>
</li>
<li><p>数据线数和地址线数共同反映存储芯片容量的大小。如地址线10根，数据线8根，则容量=2<sup>10</sup> x 8 = 8K</p>
</li>
</ul>
</li>
<li><p>SRAM、DRAM的工作原理</p>
<p>都以电信号的形式存储0/1，断电就丢失信息。易失性存储器</p>
<ul>
<li>SRAM常用作Cache，DRAM常用作主存</li>
<li>DRAM 的三种刷新方式</li>
</ul>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0838.png" alt="img_0838" style="zoom: 25%">
</li>
<li><p>ROM的特点和基本类型</p>
<p>只读存储器ROM</p>
</li>
</ul>
</li>
</ul>
  <img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0839.png" alt="img_0835" style="zoom: 25%">

<ul>
<li><p>基本概念</p>
<ul>
<li>分类</li>
<li>性能指标<ul>
<li>存储容量</li>
<li>单位成本</li>
<li>存储速度</li>
</ul>
</li>
</ul>
</li>
<li><p>主存与CPU的连接</p>
</li>
</ul>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0840.png" alt="img_0840" style="zoom: 25%">

<ul>
<li><p>双口RAM和多模块存储器</p>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0841.png" alt="img_0840" style="zoom: 25%">

</li>
</ul>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><ul>
<li>空间局部性。未来要用到的信息很可能是现在正在使用的存储空间邻近的信息</li>
<li>时间局部性，未来用到的信息，很可能现在正使用的信息</li>
</ul>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0842.png" alt="img_0842" style="zoom: 25%">

<ul>
<li><p>Cache的工作原理</p>
<p>主存的块应当放到Cache的哪个位置，怎样放？</p>
<ul>
<li>地址映射方式</li>
<li><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0843.png" alt="img_0840" style="zoom: 25%">

</li>
</ul>
<p>Cache满了怎么办？如何替换</p>
<ul>
<li>替换算法</li>
</ul>
<p>Cache如何写入数据？</p>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0844.png" alt="img_0840" style="zoom: 25%">

</li>
</ul>
<h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0845.png" alt="img_0845" style="zoom: 25%">

<h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><ul>
<li><p>指令格式</p>
</li>
<li><p>操作码与地址码</p>
</li>
<li><p>数据存放</p>
<p>  寻址，给出一个字地址，可以取出长度为一个字的数据，</p>
<p>   数据存储的方式分为大、小端模式。</p>
</li>
<li><p>指令寻址</p>
<p>定位指令的地址，顺序寻址、跳跃寻址。基于寄存器程序计数器PC</p>
</li>
<li><p>数据寻址</p>
<p>确定指令的操作地址</p>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0846.png" alt="img_0845" style="zoom: 25%">
</li>
<li><p>操作数类型</p>
<ul>
<li>地址  无符号数</li>
<li>数字</li>
<li>字符</li>
<li>逻辑数</li>
</ul>
</li>
<li><p>CISC 和 RISC</p>
</li>
</ul>
<h4 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h4><p>​    运算器与控制器</p>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0848.png" alt="img_0848" style="zoom:25%;">

<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0847.png" alt="img_0847" style="zoom:25%;">

<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0849.png" alt="img_0849" style="zoom:25%;">

<ul>
<li>数据通路，CPU内部单总线方式<ul>
<li>寄存器之间的数据传送</li>
<li>CPU与主存的数据传送</li>
<li>执行算术或逻辑运算</li>
</ul>
</li>
</ul>
<h4 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h4><ul>
<li><p>影响流水线的因素</p>
<ul>
<li>资源冲突（争用同一资源）结构相关</li>
<li>数据相关，数据冲突。后一资源必须等待前一条执行才能执行<ul>
<li>数据旁路技术</li>
<li>暂停一个或多个时钟周期</li>
<li>编译优化</li>
</ul>
</li>
<li>控制相关，遇到转移指令和其他改变PC值的指令时发生<ul>
<li>分支预测</li>
<li>预取得两个方向的指令</li>
<li>加快和提前形成条件码</li>
<li>提高转移方向的猜准率</li>
</ul>
</li>
</ul>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0851.png" alt="img_0851" style="zoom:25%;">

</li>
</ul>
<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h4 id="总线的概念与分类"><a href="#总线的概念与分类" class="headerlink" title="总线的概念与分类"></a>总线的概念与分类</h4><ul>
<li>总线的特性</li>
<li>总线的分类<ul>
<li>数据传输格式，串行和并行</li>
<li>按照功能， 片内总线，系统总线，通信总线</li>
<li>时序 同步、异步</li>
</ul>
</li>
</ul>
<h4 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h4><ul>
<li>总线的传输周期</li>
<li></li>
<li>总线时钟周期</li>
<li>总线工作频率</li>
<li>总线时钟频率</li>
<li>总线宽度</li>
<li>总线带宽</li>
<li>总线复用</li>
<li>信号线数</li>
</ul>
<h4 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h4><ul>
<li>同一时间只能有一个设备控制总线传输操作，可以有一个或者多个设备从总线接受数据</li>
<li>将总线上设备科分为主设备，从设备。</li>
</ul>
<p>​    <img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0854.png" alt="img_0854" style="zoom:25%;"></p>
<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0856.png" alt="img_0856" style="zoom:25%;">

<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0857.png" alt="img_0857" style="zoom:25%;">

<img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0859.png" alt="img_0859" style="zoom:25%;">

<h4 id="总线操作定时"><a href="#总线操作定时" class="headerlink" title="总线操作定时"></a>总线操作定时</h4><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><img src="/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/img_0860.png" alt="img_0860" style="zoom:25%;">

<h4 id="IO的概念"><a href="#IO的概念" class="headerlink" title="IO的概念"></a>IO的概念</h4><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><h4 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a>外存储器</h4><h4 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h4><h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>记uniapp组件坑</title>
    <url>/2020/09/24/%E8%AE%B0uniapp%E7%BB%84%E4%BB%B6%E5%9D%91/</url>
    <content><![CDATA[<h4 id="uniapp组件"><a href="#uniapp组件" class="headerlink" title="uniapp组件"></a>uniapp组件</h4><ul>
<li>引入的坑</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//失败的例子，在app.vue中</span></span><br><span class="line"><span class="keyword">import</span> playView <span class="keyword">from</span> <span class="string">&#x27;@/components/playView/playView&#x27;</span></span><br><span class="line">components:&#123;</span><br><span class="line">    playView</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成功的例子，在main.js中</span></span><br><span class="line"><span class="keyword">import</span> playView <span class="keyword">from</span> <span class="string">&#x27;./components/playView/playView.vue&#x27;</span></span><br><span class="line">Vue.component(<span class="string">&#x27;play-view&#x27;</span>, playView)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>子组件调用父组件的坑，注意这里是@不是: ，这个语法用太少了。。。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//父组件引用子组件,</span></span><br><span class="line">&lt;play-view @hidePlayView=<span class="string">&quot;hidePlayView&quot;</span>&gt;&lt;/play-view&gt;</span><br><span class="line"><span class="comment">//父组件的方法</span></span><br><span class="line">hidePlayView()&#123;</span><br><span class="line">    <span class="built_in">this</span>.$refs.playView.hide()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件内容</span></span><br><span class="line">&lt;button @click=<span class="string">&quot;hide&quot;</span>&gt;hideView&lt;/button&gt;</span><br><span class="line">hide()&#123;</span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&#x27;hidePlayView&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在vue中使用vuex的问题</p>
<ul>
<li>问题，多个组件同时使用了this.$store.song的数据。当A组件使用this.$store.commit更新song的某一个数据后，打印出在this.$store.song的数据却是发生了变化，却没有触发b组件的computed属性。这是为什么？而当更新song数据的全部属性时，computed发生了变化</li>
<li>最后是通过其他方式解决了这个问题<ul>
<li>我是想通过监听vuex中song的state的数据变化，实现对index页面下的iac播放器的控制，结果发现当改变了后却没有用，index下的computed监听事件没有变化。因此我后续给组件传入了iac对象解决了这个问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>全局对象的坑</p>
<p>uniapp据说有四种全局对象的方式，试了两种</p>
<ul>
<li>Vue.prototype  原型对象模式， 在main.js中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挂载</span></span><br><span class="line">Vue.prototype.$iac = uni.createInterAudioContext()</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="built_in">this</span>.$iac</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​        在app.vue的全局对象中    </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalData:&#123;</span><br><span class="line">			iac:iac</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//使用，这就是坑啊。需要先引入才能使用</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">&#x27;../../App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">app.globalData.iac<span class="comment">//使用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>computed返回api坑</p>
<p>遇到一个bug，因为如果在设置当前播放的时间点时，uniapp给的api用computed接收是不管用的。中间试过</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;<span class="comment">//监听不到api的变化。nowTime不会实时改变</span></span><br><span class="line">	nowTime()&#123;<span class="keyword">return</span> <span class="built_in">this</span>.iac.currentTime&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提示nowTime已经被创建</span></span><br><span class="line">computed:&#123;</span><br><span class="line">	nowTime()&#123;</span><br><span class="line">		<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>.iac.currentTime&#125;, <span class="number">1000</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后通过再创建了一个数据实现了，这里遇到了一个坑。我只会用到nowTime2数据。而nowTime我本来是准备不管的。可是如果在Dom上没有nowTime的话，这个computed也不会执行。于是需要使用nowTime。&lt;p style=&quot;display: none;&quot;&gt;&#123;&#123;nowTime&#125;&#125;&lt;/p&gt;把它隐藏掉就可以了</span></span><br><span class="line">computed: &#123;</span><br><span class="line">	nowTime()&#123;</span><br><span class="line">		<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			<span class="comment">// console.log(this.iac)</span></span><br><span class="line">			<span class="built_in">this</span>.nowTime2 = <span class="built_in">this</span>.iac.currentTime</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;chufale&#x27;</span>)</span><br><span class="line">		&#125;, <span class="number">1000</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Vue组件获取不到offset？</p>
<ul>
<li>因为我是用api控制的播放器播放，所以下方的进度条也是我模拟的，这个进度条并不支持拖动返回当前百分比的操作，于是我准备自己写一个。那么问题就出现在这了。<ul>
<li>想法：进度条我只要知道最左点和最右点的位置。然后再获取用户触摸的点位置。不就能轻易的定位了？</li>
<li>实行：事实上是可以做的，但是需要解决一个问题。每个用户手机肯定不能是完全一样的。必须在每次组件创建后获取到进度条相对于屏幕的位置。这样应该就可以了</li>
<li>开始准备用ref绑定元素，可是打印了Vue component后没有看到任何关于屏幕偏移量的属性。网络上搜索了一圈也没有看到。最后不得已使用了js原生方法getBoundingClientRect()</li>
<li>最后获取的点击位置没有减去左偏移量，每次都多了一段，笑了。不过还是 很快发现并解决啦</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">move(e)&#123;</span><br><span class="line">    <span class="built_in">this</span>.nowTime2 = (e.detail.x - <span class="built_in">this</span>.progressLeft)/(<span class="built_in">this</span>.progressRight-						<span class="built_in">this</span>.progressLeft)*<span class="built_in">this</span>.allTime</span><br><span class="line">    <span class="built_in">this</span>.iac.seek(<span class="built_in">this</span>.nowTime2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新，uni是有自己的api的，这种方式在h5可以，但是在app端不行所以建议uni</span></span><br><span class="line">move2(e)&#123;</span><br><span class="line">    <span class="keyword">const</span> query = uni.createSelectorQuery().in(<span class="built_in">this</span>);</span><br><span class="line">    query.select(<span class="string">&#x27;.progress&#x27;</span>).boundingClientRect(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nowTime2 = (e.detail.x - data.left)/(data.right - data.left)*<span class="built_in">this</span>.allTime</span><br><span class="line">        <span class="built_in">this</span>.percent = <span class="built_in">this</span>.nowTime2/<span class="built_in">this</span>.allTime*<span class="number">100</span></span><br><span class="line">        <span class="built_in">this</span>.iac.seek(<span class="built_in">this</span>.nowTime2)</span><br><span class="line">    &#125;).exec();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>uniapp无法使得swiper组件的swiper item 自动高度！</p>
<ul>
<li>好家伙，这东西有一个默认高度，如果是做轮播图用可以，但是把它当做一个页面使用的时候就不对劲了，如果给的高度不对默认会被隐藏，这可不行，因为页面的东西有时候不会给高度的，多高我也不知道。但是给这个东西设置min-height max-height, height: auto 都不顶用。所以要考虑别的办法了</li>
<li>先进入页面，然后再获取被隐藏的高度给swiper-item</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>过渡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//uni是有自己的过渡组件的，但是我还是习惯使用了vue的</span></span><br><span class="line">&lt;transition&gt;</span><br><span class="line">	&lt;div&gt;要过渡的组件&lt;/div&gt;    </span><br><span class="line">&lt;/transition&gt;</span><br><span class="line">.v-enter-active, .v-leave-active &#123;</span><br><span class="line">	      transition: all <span class="number">.5</span>s</span><br><span class="line">	&#125;</span><br><span class="line">	.v-enter, .v-leave-active &#123;</span><br><span class="line">	      opacity: <span class="number">0</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐播放界面毛玻璃</title>
    <url>/2020/10/14/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E7%95%8C%E9%9D%A2%E6%AF%9B%E7%8E%BB%E7%92%83/</url>
    <content><![CDATA[<h4 id="实现播放界面毛玻璃效果"><a href="#实现播放界面毛玻璃效果" class="headerlink" title="实现播放界面毛玻璃效果"></a>实现播放界面毛玻璃效果</h4><p>直接上代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">	<span class="selector-id">#app</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line"><span class="css">		<span class="selector-class">.bg-image</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">			width: 100%;</span><br><span class="line">			height: 100%;</span><br><span class="line">            background: url(&#x27;xx&#x27;);</span><br><span class="line">            filter: blur(15px);</span><br><span class="line">            background: &#x27;linear-gradient(rgba(255,255,255,.7),rgba(255,255,255,.2),rgba(255,255,255,.9)),no-repeat,url(&#x27;imageUrl&#x27;)&#x27;;</span><br><span class="line"><span class="css">            <span class="selector-tag">opacity</span>: <span class="selector-class">.6</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.bg-mask</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line"><span class="css">           <span class="selector-tag">background-color</span>: <span class="selector-tag">hsla</span>(0,0,100%,<span class="selector-class">.5</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bg-image&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--&lt;div class=&quot;bg-mask&quot;&gt;&lt;/div&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以前是直接在app下用背景做的，一直没有办法实现这种效果。只能做出透明度改变的效果。而且如果这样做容易影响到所有元素的透明度。今天看了下网易云的网页版，是按照bg-mask+bg-image做的。今天试验了一下，可以成功。后来想，如果image已经有blur效果了，为什么要在前面加一个mask呢，结果去掉了mask居然没有任何改变。。</p>
<p>补习一下fliter属性，filter 属性定义了元素(通常是<img>)的可视效果(例如：模糊与饱和度)。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-filter</span>:  <span class="comment">/* Chrome, Safari, Opera */</span></span><br><span class="line">    filter: none | <span class="built_in">blur</span>(px)//高斯模糊 | <span class="built_in">brightness</span>(%) | <span class="built_in">contrast</span>(%) | <span class="built_in">drop-shadow</span>() | <span class="built_in">grayscale</span>() | <span class="built_in">hue-rotate</span>() | <span class="built_in">invert</span>() | <span class="built_in">opacity</span>(%) | <span class="built_in">saturate</span>() | <span class="built_in">sepia</span>() | <span class="built_in">url</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js效果</category>
      </categories>
  </entry>
</search>
